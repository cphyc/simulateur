(* Sur la représentation des entiers :
   On choisit une représentation sur ? bits.
   Bit 0 de poid faible.
   Bit ? représentant le signe. *)

const s = 2

zero<n>() = o:[n] where
	if n=0 then
		o = [];
	else
		o=0.zero<n-1>()
	end if
end where

adder<n> (a:[n], b:[n], c_in) = (o:[n], c_out) where
	if n = 0 then
		o = [];
		c_out = c_in
	else if n=1 then
		o = a^b^c_in;
		c_out = (a&b)+((a+b)&c_in);
	else
		(o1, c_out1) = adder <n-1> (a[..n-2], b[..n-2], c_in);
		o2 = (a[n-1] ^ b[n-1]) ^ c_out1;
		c_out = (a[n-1] & b[n-1]) + ((a[n-1] ^ b[n-1]) & c_out1);
		o = o1 . o2
	end if
	end if
end where

add<n> (a:[n],b:[n]) = o:[n] where
	(o,c) = adder<n>(a,b,0)
end where

sub<n> (a:[n], b:[n]) = o:[n] where
	c = not b;
	(o, k) = adder<n> (a, c, 1)
end where

min<n> (a:[n]) = o:[n] where
	(o,c) = adder<n>(not a,zero<n>(),1)
end where

mul<n> (a:[n], b:[n]) = o:[2*n] where
	if n = 0
	then
		o = [];
	else if n=1
	then
		o=(a&b).0;
	else if n=(n/2)*2 then
		a0 = a[..n/2-1];
		b0 = b[..n/2-1];
		a1 = a[n/2..];
		b1 = b[n/2..];
		c = mul<n/2> (a0, b0);
		d = mul<n/2> (a1, b0);
		e = mul<n/2> (a0, b1);
		f = mul<n/2> (a1, b1);
		zn2= zero<n/2>();
		zn = zn2.zn2;
		c1 = c.zn;
		d0 = zn2.d;
		d1 = d0.zn2;
		e0 = zn2.e;
		e1 = e0.zn2;
		f1 = zn.f;
		o1 = add<2*n>(c1,f1);
		o2 = add<2*n>(d1,e1);
		o = add<2*n>(o1,o2);
	else
		o1 = mul<n+1>(a.0, b.0);
		o = o1[0..2*n-1];
	end if
	end if
	end if
end where

main (a:[s],b:[s]) = o:[s] where
	o1 = zero<2*s>();
	o2 = zero<2*s>();
	o = add<s>(a,b);
end where

\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{bbm}
\usepackage{epstopdf}
\usepackage{pdfpages}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{amsmath}
\usetheme{default}
\usecolortheme{seahorse}
\usepackage{mathtools}
\usepackage{tikz}
\usetikzlibrary{arrows,automata,calc,decorations.pathmorphing,backgrounds,positioning}

%\beamertemplatenavigationsymbolsempty
%\setbeamertemplate{navigation symbols}{} 

\usepackage[T1]{fontenc}


\hypersetup{pdfstartview={FitH}}
\begin{document}

\makeatletter

\title{A Watch Using Subleq}
\author{Baptiste Lefebvre, Li-yao Xia, Antonin Delpeuch}
\date{2013/01/22 15 : 55}

\begin{frame}
    \maketitle
\end{frame}

\begin{frame}
    \frametitle{Outline}
    \tableofcontents
\end{frame}
\section{The \texttt{subleq} language}
\subsection{Motivation}

\begin{frame}
    \frametitle{Motivation}
    \begin{itemize}
        \item We discovered the MIPS architecture in compilation course.
        \item We wanted to design an original processor.
        \item We tried to keep the number of boolean gates small.
    \end{itemize}
\end{frame}

\subsection{Definition}
\begin{frame}[fragile]
    \frametitle{\texttt{subleq}}

    The instruction set is made of only one instruction written as 3
    integers :
    \\[11pt]
    \begin{verbatim}
      a b c
    \end{verbatim}
    which means :

    \begin{verbatim}
      b <- *b - *a
      if b <= 0 then go to c
      else go to next instruction
    \end{verbatim}

\end{frame}

\subsection{Examples}
\begin{frame}[fragile]{Examples}
  \begin{verbatim}
    3  4  5   8  8   8  3  0  -1     PC : 0
    3  4  5   8  0   8  3  0  -1     PC : 6
    3  4  5   9  0   8  3  0  -1     PC : 0
    3  4  5   9 -9   8  3  0  -1     ...
    3  4  5  10 -9   8  3  0  -1
    ...
  \end{verbatim}
  The code does not need to be aligned.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Examples}
Syntactic sugar : Labels, semi-colon (address of the following cell).
Common instructions can be written with \texttt{subleq}, for instance :

\begin{columns}[t]
    \begin{column}[T]{5cm}
\begin{verbatim}
move a b :
  a Z ;
  b b ;
  Z b ;
  Z Z ;

add a b c :
  c Z ;
  b Z ;
  a a ;
  Z a ;
  Z Z ;
\end{verbatim}
    \end{column}
\begin{column}[T]{5cm}
\begin{verbatim}
beqz a lbl :
   Z a L1
   Z Z L3
L1:
   a Z L2
   Z Z L3
L2:
   Z Z lbl
L3:

j lbl :
   Z Z lbl
\end{verbatim}
\end{column}
\end{columns}
\end{frame}

\section{Chip architecture}
\subsection{The cycle}

\begin{frame}[fragile]
    \frametitle{The cycle}

    \begin{columns}[t]
        \begin{column}[T]{5cm}
    \begin{enumerate}
        \item \textbf{Step 1}
            \begin{verbatim}
 Store A,
 Read address : B,
 Increment PC
            \end{verbatim}
        \item \textbf{Step 2}
            \begin{verbatim}
 Store B,
 Read address : VA
            \end{verbatim}

        \item \textbf{Step 3}
            \begin{verbatim}
 Store VA in A,
 Read address : VB
            \end{verbatim}

    \end{enumerate}
\end{column}
\begin{column}[T]{5cm}
    \begin{enumerate}
        \setcounter{enumi}{3}
        \item \textbf{Step 4}
            \begin{verbatim}
 Store VB,
 Read address : C
 Increment PC
            \end{verbatim}

        \item \textbf{Step 5}
            \begin{verbatim}
 If VB - VA <= 0
   then set PC to C,
 Read address : A at PC,
 Increment PC
             \end{verbatim}
    \end{enumerate}
\end{column}
\end{columns}

\end{frame}

\subsection{Outline of the chip}
\begin{frame}
    \frametitle{Outline}
    \centering
    \input{schema2}
\end{frame}

\section{Implementation details}

\subsection{Memory management}

\begin{frame}
e
\end{frame}

\subsection{7-segments output}

\begin{frame}
\frametitle{7-segments output}
The conversion from binary values to 7-segments output is built in the chip, in two steps :
\begin{enumerate}
    \item Binary $\rightarrow$ Binary Coded Decimal (BCD)
        
          \texttt{101010} $\rightarrow$ \texttt{0100}.\texttt{0010}
    \item BCD $\rightarrow$ 7-segments

        \texttt{0100}.\texttt{0010} $\rightarrow$ \texttt{1100110}.\texttt{0111011}
\end{enumerate}

The first step is done with the \emph{double dabble} algorithm, the second step using a circuit derived
from the desired truth table.

\end{frame}

\begin{frame}
    \frametitle{Double dabble}

    How to multiply by 2 a number written in BCD ?

    If the digits are all less than 5, one shift is enough.
    Adding a carry if a digit is $\geq$ 5 is necessary
\end{frame}

\end{document}


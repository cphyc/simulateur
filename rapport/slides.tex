\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{bbm}
\usepackage{SevenSeg}
\usepackage{epstopdf}
\usepackage{pdfpages}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{amsmath}
\usetheme{default}
\usecolortheme{seahorse}
\usepackage{mathtools}
\usepackage{tikz}
\usetikzlibrary{arrows,automata,calc,decorations.pathmorphing,backgrounds,positioning}

%\beamertemplatenavigationsymbolsempty
%\setbeamertemplate{navigation symbols}{} 

\usepackage[T1]{fontenc}


\hypersetup{pdfstartview={FitH}}


\begin{document}

\makeatletter

\title{A Watch Using Subleq}
\author{Baptiste Lefebvre, Li-yao Xia, Antonin Delpeuch}
\date{\begin{tikzpicture}[scale=0.25, every node/.style={transform shape}]
        \node at (0,0) (n0) {};
        \SSGNb[0.75cm]{n0}{2}
        \node at (1,0) (n1) {};
        \SSGNb[0.75cm]{n1}{0}
        \node at (2,0) (n2) {};
        \SSGNb[0.75cm]{n2}{1}
        \node at (3,0) (n3) {};
        \SSGNb[0.75cm]{n3}{3}
        \node at (4.5,0) (n4) {};
        \SSGNb[0.75cm]{n4}{0}
        \node at (5.5,0) (n5) {};
        \SSGNb[0.75cm]{n5}{1}
        \node at (7,0) (n6) {};
        \SSGNb[0.75cm]{n6}{2}
        \node at (8,0) (n7) {};
        \SSGNb[0.75cm]{n7}{2}
        \node at (9.5,0) (n8) {};
        \SSGNb[0.75cm]{n8}{1}
        \node at (10.5,0) (n9) {};
        \SSGNb[0.75cm]{n9}{5}
        \node at (12,0) (n10) {};
        \SSGNb[0.75cm]{n10}{5}
        \node at (13,0) (n11) {};
        \SSGNb[0.75cm]{n11}{5}
  \end{tikzpicture}}

\begin{frame}
    \maketitle
\end{frame}

\begin{frame}
    \frametitle{Layout}
    \tableofcontents
\end{frame}

\section{The \texttt{Subleq} language}
\subsection{Motivation}

\begin{frame}
    \frametitle{Motivation}
    \begin{itemize}
        \item We discovered the MIPS architecture in compilation course.
        \item We wanted to design an original processor.
        \item We tried to keep the number of boolean gates small.
    \end{itemize}
\end{frame}

\subsection{Definition}
\begin{frame}[fragile]
    \frametitle{\texttt{Subleq}}

    The instruction set is made of only one instruction written as 3
    integers :
    \\[11pt]
    \begin{verbatim}
      a b c
    \end{verbatim}
    which means :

    \begin{verbatim}
      b <- *b - *a
      \textbf{if} b <= 0 then go to c
      else go to next instruction
    \end{verbatim}

\end{frame}

\subsection{Examples}
\begin{frame}[fragile]{Examples}
  \begin{verbatim}
    3  4  5   8  8   8  3  0  -1     PC : 0
    3  4  5   8  0   8  3  0  -1     PC : 6
    3  4  5   9  0   8  3  0  -1     PC : 0
    3  4  5   9 -9   8  3  0  -1     ...
    3  4  5  10 -9   8  3  0  -1
    ...
  \end{verbatim}
  The code does not need to be aligned.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Examples}
Syntactic sugar : Labels, semi-colon (address of the following cell).
Common instructions can be written with \texttt{subleq}, for instance :

\begin{columns}[t]
    \begin{column}[T]{3cm}
\begin{verbatim}
move a b :
  a Z ;
  b b ;
  Z b ;
  Z Z ;

add a b c :
  c Z ;
  b Z ;
  a a ;
  Z a ;
  Z Z ;
\end{verbatim}
    \end{column}
\begin{column}[T]{3cm}
\begin{verbatim}
beqz a lbl :
   Z a L1
   Z Z L3
L1:
   a Z L2
   Z Z L3
L2:
   Z Z lbl
L3:

j lbl :
   Z Z lbl
\end{verbatim}
\end{column}
\end{columns}
\end{frame}

\section{Chip architecture}
\subsection{Cycle}

\begin{frame}[fragile]
    \frametitle{The cycle}
\begin{columns}[t]
	\begin{column}[T]{4cm}
    \begin{enumerate}
      \setcounter{enumi}{0}
        \item
          \begin{verbatim}
Store A
Read address : B
Increment PC
          \end{verbatim}
        \item
          \begin{verbatim}
Store B
Read address : VA
          \end{verbatim}
        \item
	        \begin{verbatim}
Store VA in A
Read address : VB
          \end{verbatim}
  	\end{enumerate}
	\end{column}
	\begin{column}[T]{6cm}
  	\begin{enumerate}
  	  \setcounter{enumi}{3}
  	    \item
  	      \begin{verbatim}
Store VB
Read address : C
Increment PC
  	      \end{verbatim}
  	    \item 
  	      \begin{verbatim}
If VB - VA <= 0
  then set PC to C
Read address : A at PC
Increment PC
  	      \end{verbatim}
  	\end{enumerate}
	\end{column}
\end{columns}

\end{frame}

\subsection{Chip layout}
\begin{frame}
    \frametitle{Layout}
    \centering
    \input{schema2}
\end{frame}

\section{Implementation details}

\subsection{Memory management}

\begin{frame}
    \frametitle{Memory controller}
e
\end{frame}

\subsection{7-segments display}

\begin{frame}
\frametitle{7-segments display}
The conversion from binary values to 7-segments display is built in the chip, in two steps :
\begin{enumerate}
    \item Binary $\rightarrow$ Binary Coded Decimal (BCD)
        
          \texttt{101010} $\rightarrow$ \texttt{0100}.\texttt{0010}
    \item BCD $\rightarrow$ 7-segments

        \texttt{0100}.\texttt{0010} $\rightarrow$ \texttt{1100110}.\texttt{0111011}
\end{enumerate}

The first step is done with the \emph{double dabble} algorithm, the second step using a circuit derived
from the desired truth table.

\end{frame}

\begin{frame}
    \frametitle{Double dabble}

    How to multiply by 2 a number written in BCD ?

    If the digits are all less than 5, one shift is enough.
    Otherwise we propagate a carry by adding 3 to the digit before shifting it.

    \begin{columns}[t]
        \begin{column}[T]{5cm}
            \vspace{1cm}
    \begin{tikzpicture}
        \node at (-0.75,0.5) {2};
        \node at (0.75,0.5) {3};
        \node (init) {\texttt{0 0 1 0 0 0 1 1}};
        \node at (0,-0.4) (next) {\texttt{0 1 0 0 0 1 1 0}};
        \draw (0,0.2) -- (0,-0.6);
        \node at (-0.75,-0.9) {4};
        \node at (0.75,-0.9) {6};
        \node at (2.1,-0.4) (sh) {shift};
    \end{tikzpicture}
        \end{column}
        \begin{column}[T]{5cm}
            \vspace{1cm}
  \begin{tikzpicture}
        \node at (-0.75,0.5) {4};
        \node at (0.75,0.5) {6};
        \node (init) {\texttt{0 1 0 0 0 1 1 0}};
        \node at (0,-0.4) (next) {\texttt{0 1 0 0 1 0 0 1}};
        \node at (0,-0.8) (next) {\texttt{1 0 0 1 0 0 1 0}};
        \draw (0,0.2) -- (0,-1);
        \node at (-0.75,-1.3) {9};
        \node at (0.75,-1.3) {2};
        \node at (2.2,-0.4) (add3) {add 3};
        \node at (2.1,-0.8) (sh) {shift};
    \end{tikzpicture}

        \end{column}
    \end{columns}

    We add 3 because $2*(5 + 3) = 16$.
\end{frame}

\begin{frame}
    \frametitle{Implementation}

    \input{double-dabble}

\end{frame}


\begin{frame}[fragile]
    \frametitle{Time management}

    As the number of instructions executed per second is constant, our watch program has to sleep by itself until
    the next second.

    \begin{verbatim}
...
p40 cyclesleft ;  ##
# reset minutes
-2 -2 ;
...
    \end{verbatim}

    This is achieved by adding some instructions to count the number of instructions executed during the computation.
    Then the program loops until the right number of instructions is reached.
\end{frame}


\end{document}


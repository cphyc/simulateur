\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{bbm}
\usepackage{SevenSeg}
\usepackage{epstopdf}
\usepackage{pdfpages}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{amsmath}
\usetheme{default}
\usecolortheme{seahorse}
\usepackage{mathtools}
\usepackage{tikz}
\usepackage{alltt}
\usetikzlibrary{arrows,automata,calc,decorations.pathmorphing,backgrounds,positioning}

%\beamertemplatenavigationsymbolsempty
%\setbeamertemplate{navigation symbols}{} 

\usepackage[T1]{fontenc}


\hypersetup{pdfstartview={FitH}}


\begin{document}

\makeatletter

\title{A Watch Using Subleq}
\author{Baptiste Lefebvre, Li-yao Xia, Antonin Delpeuch}
\date{\begin{tikzpicture}[scale=0.25, every node/.style={transform shape}]
        \node at (0,0) (n0) {};
        \SSGNb[0.75cm]{n0}{2}
        \node at (1,0) (n1) {};
        \SSGNb[0.75cm]{n1}{0}
        \node at (2,0) (n2) {};
        \SSGNb[0.75cm]{n2}{1}
        \node at (3,0) (n3) {};
        \SSGNb[0.75cm]{n3}{3}
        \node at (4.5,0) (n4) {};
        \SSGNb[0.75cm]{n4}{0}
        \node at (5.5,0) (n5) {};
        \SSGNb[0.75cm]{n5}{1}
        \node at (7,0) (n6) {};
        \SSGNb[0.75cm]{n6}{2}
        \node at (8,0) (n7) {};
        \SSGNb[0.75cm]{n7}{2}
        \node at (9.5,0) (n8) {};
        \SSGNb[0.75cm]{n8}{1}
        \node at (10.5,0) (n9) {};
        \SSGNb[0.75cm]{n9}{5}
        \node at (12,0) (n10) {};
        \SSGNb[0.75cm]{n10}{5}
        \node at (13,0) (n11) {};
        \SSGNb[0.75cm]{n11}{5}
  \end{tikzpicture}}

\begin{frame}
    \maketitle
\end{frame}

\begin{frame}
    \frametitle{Layout}
    \tableofcontents
\end{frame}

\section{The \texttt{Subleq} language}
\subsection{Motivation}

\begin{frame}
    \frametitle{Motivation}
    \begin{itemize}
        \item We already discovered the MIPS architecture
          in the compilation course.
        \item Design an original processor.
        \item Keep the number of boolean gates small.
        \item \texttt{Subleq} is a lot of fun to write !
    \end{itemize}
\end{frame}

\subsection{Definition}
\begin{frame}[fragile]
    \frametitle{\texttt{Subleq}}
    The instruction set is made of only one instruction written as 3
    integers :
    \\[11pt]
    \begin{verbatim}
      a b c
    \end{verbatim}
    which means :

    \begin{alltt}
       b \(\leftarrow\) *b - *a
      {\bf if} b \(\leq\) 0
      {\bf then} go to c
      {\bf else} go to next instruction
    \end{alltt}

\end{frame}

\begin{frame}
  \frametitle{\texttt{Subleq}}
  \begin{itemize}
    \item Subleq code is a sequence of integers, which initialize
      a contiguous memory block starting from address 0.
    \item A program counter initialized at 0 points to the next
      instruction to execute.
    \item Data and instructions in the same place.
  \end{itemize}
\end{frame}

\subsection{Examples}
\begin{frame}[fragile]{Examples}
  \begin{verbatim}
    3  4  5   8  8   8  3  0  -1     PC : 0
    3  4  5   8  0   8  3  0  -1     PC : 6
    3  4  5   9  0   8  3  0  -1     PC : 0
    3  4  5   9 -9   8  3  0  -1     ...
    3  4  5  10 -9   8  3  0  -1
    ...
  \end{verbatim}
  An instruction does not need to be aligned.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Examples}
Syntactic sugar : Labels, semi-colon (address of the following cell).
Common instructions can be written with \texttt{subleq}, for instance :

\begin{columns}[t]
    \begin{column}[T]{3cm}
\begin{alltt}
{\bf move} a b :
   a Z ;
   b b ;
   Z b ;
   Z Z ;

{\bf add} a b c :
   c Z ;
   b Z ;
   a a ;
   Z a ;
   Z Z ;
\end{alltt}
    \end{column}
\begin{column}[T]{3cm}
\begin{alltt}
{\bf beqz} a lbl :
   	Z a L1
   	Z Z L3
 L1:
    a Z L2
    Z Z L3
 L2:
    Z Z lbl
 L3:

{\bf j} lbl :
    Z Z lbl
\end{alltt}
\end{column}
\end{columns}
\end{frame}

\section{Chip architecture}
\subsection{Cycle}

\begin{frame}[fragile]
    \frametitle{The cycle}
\begin{columns}[t]
	\begin{column}[T]{4cm}
    \begin{enumerate}
      \setcounter{enumi}{0}
        \item
          \begin{verbatim}
Store A
Read address : B
Increment PC
          \end{verbatim}
        \item
          \begin{verbatim}
Store B
Read address : VA
          \end{verbatim}
        \item
	        \begin{verbatim}
Store VA in A
Read address : VB
          \end{verbatim}
  	\end{enumerate}
	\end{column}
	\begin{column}[T]{6cm}
  	\begin{enumerate}
  	  \setcounter{enumi}{3}
  	    \item
  	      \begin{verbatim}
Store VB
Read address : C
Increment PC
  	      \end{verbatim}
  	    \item 
  	      \begin{verbatim}
If VB - VA <= 0
  then set PC to C
Read address : A at PC
Increment PC
  	      \end{verbatim}
  	\end{enumerate}
	\end{column}
\end{columns}

\end{frame}

\subsection{Chip layout}
\begin{frame}
    \frametitle{Layout}
    \centering
    \input{schema2}
\end{frame}

\section{Implementation details}


\subsection{Memory management}

\begin{frame}
	\frametitle{Memory management}
	\centering
	\input{schema3}
\end{frame}

\subsection{7-segments display}

\begin{frame}
\frametitle{7-segments display}
The conversion from binary values to 7-segments display is built in the chip, in two steps :
\begin{enumerate}
    \item Binary $\rightarrow$ Binary Coded Decimal (BCD)
        
          \texttt{101010} $\rightarrow$ \texttt{0100}.\texttt{0010}
    \item BCD $\rightarrow$ 7-segments

        \texttt{0100}.\texttt{0010} $\rightarrow$ \texttt{1100110}.\texttt{0111011}
\end{enumerate}

The first step is done with the \emph{double dabble} algorithm, the second step using a circuit derived
from the desired truth table.

\end{frame}

\begin{frame}
    \frametitle{Double dabble}

    How to multiply by 2 a number written in BCD ?

    If the digits are all less than 5, one shift is enough.
    Otherwise we propagate a carry by adding 3 to the digit before shifting it.

    \begin{columns}[t]
        \begin{column}[T]{5cm}
            \vspace{1cm}
    \begin{tikzpicture}
        \node at (-0.75,0.5) {2};
        \node at (0.75,0.5) {3};
        \node (init) {\texttt{0 0 1 0 0 0 1 1}};
        \node at (0,-0.4) (next) {\texttt{0 1 0 0 0 1 1 0}};
        \draw (0,0.2) -- (0,-0.6);
        \node at (-0.75,-0.9) {4};
        \node at (0.75,-0.9) {6};
        \node at (2.1,-0.4) (sh) {shift};
    \end{tikzpicture}
        \end{column}
        \begin{column}[T]{5cm}
            \vspace{1cm}
  \begin{tikzpicture}
        \node at (-0.75,0.5) {4};
        \node at (0.75,0.5) {6};
        \node (init) {\texttt{0 1 0 0 0 1 1 0}};
        \node at (0,-0.4) (next) {\texttt{0 1 0 0 1 0 0 1}};
        \node at (0,-0.8) (next) {\texttt{1 0 0 1 0 0 1 0}};
        \draw (0,0.2) -- (0,-1);
        \node at (-0.75,-1.3) {9};
        \node at (0.75,-1.3) {2};
        \node at (2.2,-0.4) (add3) {add 3};
        \node at (2.1,-0.8) (sh) {shift};
    \end{tikzpicture}

        \end{column}
    \end{columns}

    We add 3 because $2*(5 + 3) = 16$.
\end{frame}

\begin{frame}
  \frametitle{Implementation}

  \input{double-dabble}

\end{frame}


\begin{frame}[fragile]
    \frametitle{Time management}

    As the number of instructions executed per second is constant, our watch program has to sleep by itself until
    the next second.

    \begin{verbatim}
...
p40 cyclesleft ;  ##
# reset minutes
-2 -2 ;
...
    \end{verbatim}

    This is achieved by adding some instructions to count the number of instructions executed during the computation.
    Then the program loops until the right number of instructions is reached.
\end{frame}


\end{document}


\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{bbm}
\usepackage{SevenSeg}
\usepackage{epstopdf}
\usepackage{pdfpages}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{amsmath}
\usetheme{default}
\usecolortheme{seahorse}
\usepackage{mathtools}
\usepackage{tikz}
\usepackage{alltt}
\usetikzlibrary{arrows,automata,calc,decorations.pathmorphing,backgrounds,positioning}

%\beamertemplatenavigationsymbolsempty
%\setbeamertemplate{navigation symbols}{} 

\usepackage[T1]{fontenc}


\hypersetup{pdfstartview={FitH}}

\title{A Watch Using \texttt{Subleq}}
\author{Baptiste Lefebvre, Li-yao Xia, Antonin Delpeuch}
\date{\begin{tikzpicture}[scale=0.25, every node/.style={transform shape}]
        \node at (0,0) (n0) {};
        \SSGNb[0.75cm]{n0}{2}
        \node at (1,0) (n1) {};
        \SSGNb[0.75cm]{n1}{0}
        \node at (2,0) (n2) {};
        \SSGNb[0.75cm]{n2}{1}
        \node at (3,0) (n3) {};
        \SSGNb[0.75cm]{n3}{3}
        \node at (4.5,0) (n4) {};
        \SSGNb[0.75cm]{n4}{0}
        \node at (5.5,0) (n5) {};
        \SSGNb[0.75cm]{n5}{1}
        \node at (7,0) (n6) {};
        \SSGNb[0.75cm]{n6}{2}
        \node at (8,0) (n7) {};
        \SSGNb[0.75cm]{n7}{2}
        \node at (9.5,0) (n8) {};
        \SSGNb[0.75cm]{n8}{1}
        \node at (10.5,0) (n9) {};
        \SSGNb[0.75cm]{n9}{5}
        \node at (12,0) (n10) {};
        \SSGNb[0.75cm]{n10}{5}
        \node at (13,0) (n11) {};
        \SSGNb[0.75cm]{n11}{5}
  \end{tikzpicture}}


\begin{document}

\makeatletter

\begin{frame}
    \maketitle
\end{frame}

\begin{frame}
    %\frametitle{Summary}
    \tableofcontents
\end{frame}

\section{The \texttt{Subleq} language}
\subsection{Motivation}
\begin{frame}
  \frametitle{Motivation}
  \begin{itemize}
    \item We already discovered the MIPS architecture
      in the compilation course.
    \item Design an original processor.
    \item The R in RISC may be misleading. The O in OISC is not.
    \item \texttt{Subleq} is awesome !
  \end{itemize}
\end{frame}

\subsection{An exotic architecture}
\begin{frame}{An exotic architecture}
  \begin{itemize}
    \item OISC. One Instruction Set Computer.
    \item \texttt{Subleq} achieves Turing-completeness with one instruction.
    \item A short documentation. %and that's all you will ever need
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{\texttt{Subleq}}
    The instruction set is made of only one instruction with three
    operands which represent memory addresses :
    \\[11pt]
    \begin{verbatim}
      a b c
    \end{verbatim}
    which means :

    \begin{alltt}
       b \(\leftarrow\) *b - *a
      {\bf if} b \(\leq\) 0
      {\bf then} go to c
      {\bf else} go to next instruction
    \end{alltt}

\end{frame}

\begin{frame}
  \frametitle{\texttt{Subleq}}
  \begin{itemize}
    \item \texttt{Subleq} code is a sequence of integers, which initialize
      a contiguous memory block starting from address 0.
    \item A program counter initialized at 0 keeps track of the next
      instruction to execute.
    \item Data and instructions in the same place.
  \end{itemize}
\end{frame}

\subsection{Examples}
\begin{frame}[fragile]{Examples}
  \begin{verbatim}
    3  4  5   8  8   8  3  0  -1     PC : 0
    3  4  5   8  0   8  3  0  -1     PC : 6
    3  4  5   9  0   8  3  0  -1     PC : 0
    3  4  5   9 -9   8  3  0  -1     ...
    3  4  5  10 -9   8  3  0  -1
    ...
  \end{verbatim}
  \begin{itemize}
    \item An instruction does not need to be aligned.
    \item Fun fact : You can write subleq with only a numerical keypad.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Examples}
Syntactic sugar : Labels, semi-colon (address of the following cell).
Common instructions can be written with \texttt{subleq}, for instance :

\begin{columns}[t]
  \begin{column}[T]{3cm}
    \begin{alltt}
{\bf move} a b :
   a Z ;
   b b ;
   Z b ;
   Z Z ;

{\bf add} a b c :
   c Z ;
   b Z ;
   a a ;
   Z a ;
   Z Z ;
    \end{alltt}
  \end{column}
  \begin{column}[T]{3cm}
    \begin{alltt}
{\bf beqz} a lbl :
   	Z a L1
   	Z Z L3
 L1:
    a Z L2
    Z Z L3
 L2:
    Z Z lbl
 L3:

{\bf j} lbl :
    Z Z lbl
    \end{alltt}
  \end{column}
  \end{columns}
\end{frame}

\section{Chip architecture}
\subsection{Instruction cycle}

\begin{frame}[fragile]
  \frametitle{Instruction cycle}
  Steps in decoding the instruction \verb=A B C=.
  \begin{columns}[t]
    \begin{column}[T]{4cm}
      \begin{enumerate}
        \setcounter{enumi}{0}
        \item
          \begin{verbatim}
Store A
Read address : &B
Increment PC
          \end{verbatim}
        \item
          \begin{verbatim}
Store B
Read address : A
          \end{verbatim}
        \item
	  \begin{verbatim}
Store VA in A
Read address : B
          \end{verbatim}
      \end{enumerate}
    \end{column}
    \begin{column}[T]{6cm}
      \begin{enumerate}
      \setcounter{enumi}{3}
        \item
          \begin{verbatim}
Store VB
Read address : &C
Increment PC
          \end{verbatim}
        \item 
          \begin{verbatim}
If VB - VA <= 0
  then set PC to C
Read address : &A=PC
Increment PC
          \end{verbatim}
      \end{enumerate}
    \end{column}
  \end{columns}
\end{frame}

\subsection{Chip layout}
\begin{frame}
    \frametitle{Layout}
    \centering
    \input{schema2}
\end{frame}

\section{Implementation details}


\subsection{Memory management}

\begin{frame}
	\frametitle{Memory management}
	\centering
	\input{schema3}
\end{frame}

\subsection{7-segments display}

\begin{frame}
\frametitle{7-segments display}
The conversion from binary values to 7-segments display is built in the chip, in two steps :
\begin{enumerate}
    \item Binary $\rightarrow$ Binary Coded Decimal (BCD)
        
          \texttt{101010} $\rightarrow$ \texttt{0100}.\texttt{0010}
    \item BCD $\rightarrow$ 7-segments

        \texttt{0100}.\texttt{0010} $\rightarrow$ \texttt{1100110}.\texttt{0111011}
\end{enumerate}

The first step is done with the \emph{double dabble} algorithm, the second step using a circuit derived
from the desired truth table.

\end{frame}

\begin{frame}
    \frametitle{Double dabble}

    How to multiply by 2 a number written in BCD ?

    If the digits are all less than 5, one shift is enough.
    Otherwise we propagate a carry by adding 3 to the digit before shifting it.

    \begin{columns}[t]
        \begin{column}[T]{5cm}
            \vspace{1cm}
    \begin{tikzpicture}
        \node at (-0.75,0.5) {2};
        \node at (0.75,0.5) {3};
        \node (init) {\texttt{0 0 1 0 0 0 1 1}};
        \node at (0,-0.4) (next) {\texttt{0 1 0 0 0 1 1 0}};
        \draw (0,0.2) -- (0,-0.6);
        \node at (-0.75,-0.9) {4};
        \node at (0.75,-0.9) {6};
        \node at (2.1,-0.4) (sh) {shift};
    \end{tikzpicture}
        \end{column}
        \begin{column}[T]{5cm}
            \vspace{1cm}
  \begin{tikzpicture}
        \node at (-0.75,0.5) {4};
        \node at (0.75,0.5) {6};
        \node (init) {\texttt{0 1 0 0 0 1 1 0}};
        \node at (0,-0.4) (next) {\texttt{0 1 0 0 1 0 0 1}};
        \node at (0,-0.8) (next) {\texttt{1 0 0 1 0 0 1 0}};
        \draw (0,0.2) -- (0,-1);
        \node at (-0.75,-1.3) {9};
        \node at (0.75,-1.3) {2};
        \node at (2.2,-0.4) (add3) {add 3};
        \node at (2.1,-0.8) (sh) {shift};
    \end{tikzpicture}

        \end{column}
    \end{columns}

    We add 3 because $2*(5 + 3) = 16$.
\end{frame}

\begin{frame}
  \frametitle{Implementation}

  \input{double-dabble}

\end{frame}


\begin{frame}[fragile]
  \frametitle{Time management and programming}
  \begin{itemize}
    \item 5 clock ticks per instruction.
    \item 1024 Hz
    \item Up to the watch program to keep track of elapsed cycles.
    \item Unused cycles must be spent in a loop.
    \begin{verbatim}
...
start:
p10 cyclesleft main
0 0 start

main:
...
p40 cyclesleft ;
# reset minutes
-2 -2 ;
... # a sequence of 6 more instructions
    \end{verbatim}
    \item Given a perfect clock, our watch should drift from UTC by
      less than a second a year.
    \item Keep the number of boolean gates small.
  \end{itemize}
\end{frame}


\end{document}


\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{bbm}
\usepackage{epstopdf}
\usepackage{pdfpages}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{amsmath}
\usetheme{default}
\usecolortheme{seahorse}
\usepackage{mathtools}
\usepackage{tikz}
\usepackage{alltt}
\usetikzlibrary{arrows,automata,calc,decorations.pathmorphing,backgrounds,positioning}

%\beamertemplatenavigationsymbolsempty
%\setbeamertemplate{navigation symbols}{} 

\usepackage[T1]{fontenc}


\hypersetup{pdfstartview={FitH}}


\begin{document}

\makeatletter

\title{A Watch Using Subleq}
\author{Baptiste Lefebvre, Li-yao Xia, Antonin Delpeuch}
\date{2013/01/22 15 : 55}

\begin{frame}
    \maketitle
\end{frame}

\begin{frame}
    \frametitle{Layout}
    \tableofcontents
\end{frame}

\section{The \texttt{Subleq} language}
\subsection{Motivation}

\begin{frame}
    \frametitle{Motivation}
    \begin{itemize}
        \item We discovered the MIPS architecture in compilation course.
        \item We wanted to design an original processor.
        \item We tried to keep the number of boolean gates small.
    \end{itemize}
\end{frame}

\subsection{Definition}
\begin{frame}[fragile]
    \frametitle{\texttt{Subleq}}

    The instruction set is made of only one instruction written as 3
    integers :
    \\[11pt]
    \begin{verbatim}
      a b c
    \end{verbatim}
    which means :

    \begin{alltt}
       b \(\leftarrow\) *b - *a
      {\bf if} b \(\leq\) 0
      {\bf then} go to c
      {\bf else} go to next instruction
    \end{alltt}

\end{frame}

\subsection{Examples}
\begin{frame}[fragile]{Examples}
  \begin{verbatim}
    3  4  5   8  8   8  3  0  -1     PC : 0
    3  4  5   8  0   8  3  0  -1     PC : 6
    3  4  5   9  0   8  3  0  -1     PC : 0
    3  4  5   9 -9   8  3  0  -1     ...
    3  4  5  10 -9   8  3  0  -1
    ...
  \end{verbatim}
  The code does not need to be aligned.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Examples}
Syntactic sugar : Labels, semi-colon (address of the following cell).
Common instructions can be written with \texttt{subleq}, for instance :

\begin{columns}[t]
    \begin{column}[T]{3cm}
\begin{alltt}
{\bf move} a b :
   a Z ;
   b b ;
   Z b ;
   Z Z ;

{\bf add} a b c :
   c Z ;
   b Z ;
   a a ;
   Z a ;
   Z Z ;
\end{alltt}
    \end{column}
\begin{column}[T]{3cm}
\begin{alltt}
{\bf beqz} a lbl :
   	Z a L1
   	Z Z L3
 L1:
    a Z L2
    Z Z L3
 L2:
    Z Z lbl
 L3:

{\bf j} lbl :
    Z Z lbl
\end{alltt}
\end{column}
\end{columns}
\end{frame}

\section{Chip architecture}
\subsection{Cycle}

\begin{frame}[fragile]
    \frametitle{The cycle}
\begin{columns}[t]
	\begin{column}[T]{4cm}
    \begin{enumerate}
      \setcounter{enumi}{0}
        \item
          \begin{verbatim}
Store A
Read address : B
Increment PC
          \end{verbatim}
        \item
          \begin{verbatim}
Store B
Read address : VA
          \end{verbatim}
        \item
	        \begin{verbatim}
Store VA in A
Read address : VB
          \end{verbatim}
  	\end{enumerate}
	\end{column}
	\begin{column}[T]{6cm}
  	\begin{enumerate}
  	  \setcounter{enumi}{3}
  	    \item
  	      \begin{verbatim}
Store VB
Read address : C
Increment PC
  	      \end{verbatim}
  	    \item 
  	      \begin{verbatim}
If VB - VA <= 0
  then set PC to C
Read address : A at PC
Increment PC
  	      \end{verbatim}
  	\end{enumerate}
	\end{column}
\end{columns}

\end{frame}

\subsection{Chip layout}
\begin{frame}
    \frametitle{Layout}
    \centering
    \input{schema2}
\end{frame}

\section{Implementation details}


\subsection{Memory management}

\begin{frame}
	\frametitle{Memory management}
	\centering
	\input{schema3]
\end{frame}

\subsection{7-segments display}

\begin{frame}
\frametitle{7-segments display}
The conversion from binary values to 7-segments display is built in the chip, in two steps :
\begin{enumerate}
    \item Binary $\rightarrow$ Binary Coded Decimal (BCD)
        
          \texttt{101010} $\rightarrow$ \texttt{0100}.\texttt{0010}
    \item BCD $\rightarrow$ 7-segments

        \texttt{0100}.\texttt{0010} $\rightarrow$ \texttt{1100110}.\texttt{0111011}
\end{enumerate}

The first step is done with the \emph{double dabble} algorithm, the second step using a circuit derived
from the desired truth table.

\end{frame}

\begin{frame}
    \frametitle{Double dabble}

    How to multiply by 2 a number written in BCD ?

    If the digits are all less than 5, one shift is enough.
    Adding a carry if a digit is $\geq$ 5 is necessary
\end{frame}

\end{document}

